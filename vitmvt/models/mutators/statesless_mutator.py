import random
from copy import deepcopy

import torch
import torch.distributed as dist
import torch.nn.functional as F

from vitmvt.utils import broadcast_object

from ..builder import MUTATORS
from ..mutables import MixedOp, SliceOp
from .base_mutator import BaseMutator


@MUTATORS.register_module()
class StateslessMutator(BaseMutator):
    """StateslessMutator."""

    def __init__(self, model, fixed_mutable_cfg=None, **kwargs):
        super().__init__(model)
        from mmcv.runner import get_dist_info
        rank, world_size = get_dist_info()
        self.fixed_mutable_cfg = self.load_subnet(fixed_mutable_cfg)
        self.sync_subnet_randgen = random.Random(1024)

    def sample_search(self, kind=None, searching=False, **kwargs):
        result = dict()
        memo = set()  # memorize keys seen before.
        candidate = deepcopy(
            kwargs['candidate']) if 'candidate' in kwargs else dict()
        target = deepcopy(kwargs['target']) if 'target' in kwargs else dict()
        for mutable in self.mutables:
            if isinstance(mutable, MixedOp):
                if kind == 'random':
                    gen_index = torch.multinomial(torch.ones(len(mutable)), 1)
                    index = F.one_hot(
                        gen_index, num_classes=len(mutable)).view(-1)
                    if dist.is_available() and dist.is_initialized() \
                       and not searching:
                        index = index.cuda()
                        dist.broadcast(index, src=0)
                    result[mutable.key] = index.tolist()

                elif kind == 'mutate':
                    prob = kwargs.get('prob', 0.5)
                    chosen_mask = candidate[mutable.key]
                    if random.random() < prob:
                        gen_index = random.randint(0, len(mutable) - 1)
                        chosen_mask = [0] * len(mutable)
                        chosen_mask[gen_index] = 1
                    result[mutable.key] = chosen_mask
                elif kind == 'crossover':
                    chosen_mask = candidate[mutable.key]
                    chosen_mask2 = target[mutable.key]
                    if random.random() < 0.5:
                        chosen_mask = chosen_mask2
                    result[mutable.key] = chosen_mask
                elif kind is None:
                    result[mutable.key] = self._cache[mutable.key]
                else:
                    raise ValueError(f'Unsupported kind: {kind} for MixedOp')
            elif isinstance(mutable, SliceOp):
                space_dict = dict()
                for space in mutable.space:
                    if space not in memo:
                        if kind == 'crossover':
                            space.set_curr(candidate[mutable.key][space.key])
                        if target:
                            m_target = deepcopy(space)
                            m_target.set_curr(target[mutable.key][space.key])
                            kwargs.update({'target': m_target})
                        value = space(kind=kind, **kwargs)
                        # from mmcv.runner import get_dist_info
                        # rank, _ = get_dist_info()
                        # if rank >= 48:
                        #     value = space(kind=kind, **kwargs)
                        # else:
                        #     value = space(kind='default', **kwargs)
                        # if 'shared' not in space.key:
                        #     value = space(kind='default', **kwargs)
                        # else:
                        #     value = space(kind=kind, **kwargs)
                        memo.add(space)
                    else:
                        value = space()

                    space_dict[space.key] = value
                result[mutable.key] = space_dict
        if self.fixed_mutable_cfg is not None:
            result.update(self.fixed_mutable_cfg)
        self._cache = deepcopy(result)
        return result

    def forward_mixed_op(self, mutable, *args, **kwargs):
        """Proxy function for MixedOp.

        Args:
            mutable (MixedOp): Mutable used for choosing cache args
                generated by sample_search.

        Returns:
            (nn.Tensor, mask): Generated tensor and its mask.
        """
        mask = self._cache[mutable.key]
        assert sum(mask) == 1, 'Only support single path.'
        for cand, m in zip(mutable, mask):
            if m:
                out = cand(*args, **kwargs)
                break
        return out, mask

    def forward_slice_op(self, mutable, *args, **kwargs):
        """Proxy function for SliceOp.

        Args:
            mutable (SliceOp): Mutable used for choosing cache args
                generated by sample_search.

        Returns:
            (nn.Tensor, mask): Generated tensor and its mask.
        """
        space_dict = self._cache.get(mutable.key, None)
        for space in mutable.space:
            v = space_dict[space.key]
            space.set_curr(v)
        # update space_attr according space.
        space_attr = dict()
        for k, v in mutable.space_attr.items():
            space_attr[k] = v()
        out = mutable.forward_inner(*args, **kwargs)
        return out, space_attr
        return out, space_attr
