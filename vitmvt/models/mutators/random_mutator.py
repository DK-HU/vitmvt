from copy import deepcopy

import torch
import torch.nn.functional as F

from ..builder import MUTATORS
from ..mutables import MixedOp, SliceOp
from .base_mutator import BaseMutator


@MUTATORS.register_module()
class RandomMutator(BaseMutator):
    """RandomMutator."""

    def __init__(self, model, **kwargs):
        super().__init__(model)

    def sample_search(self, *args, **kwargs):
        result = dict()
        memo = set()  # memorize keys seen before.
        for mutable in self.mutables:
            if isinstance(mutable, MixedOp):
                gen_index = torch.randint(high=len(mutable), size=(1, ))
                result[mutable.key] = F.one_hot(
                    gen_index, num_classes=len(mutable)).view(-1).tolist()
            elif isinstance(mutable, SliceOp):
                space_dict = dict()
                for space in mutable.space:
                    if space not in memo:
                        space_dict[space.key] = space(kind='random')
                        memo.add(space)
                    else:
                        space_dict[space.key] = space()
                result[mutable.key] = space_dict
        self._cache = deepcopy(result)
        return result

    def forward_mixed_op(self, mutable, *args, **kwargs):
        """Proxy function for MixedOp.

        Args:
            mutable (MixedOp): Mutable used for choosing cache args
                generated by sample_search.

        Returns:
            (nn.Tensor, mask): Generated tensor and its mask.
        """
        mask = self._cache[mutable.key]
        assert sum(mask) == 1, 'Only support single path.'
        for cand, m in zip(mutable, mask):
            if m:
                out = cand(*args, **kwargs)
                break
        return out, mask

    def forward_slice_op(self, mutable, *args, **kwargs):
        """Proxy function for SliceOp.

        Args:
            mutable (SliceOp): Mutable used for choosing cache args
                generated by sample_search.

        Returns:
            (nn.Tensor, mask): Generated tensor and its mask.
        """
        space_dict = self._cache[mutable.key]
        for space in mutable.space:
            v = space_dict[space.key]
            space.set_curr(v)
        # update space_attr according space.
        space_attr = dict()
        for k, v in mutable.space_attr.items():
            space_attr[k] = v()
        out = mutable.forward_inner(*args, **kwargs)
        return out, space_attr
